{"ast":null,"code":"/**\n * Generates a list of numbers corresponding to the 1D coordinates of the squares that are mines  \n * O(n) time, where n = rows*cols \n * @param numMines (number of mines)\n * @param rows (number of rows)\n * @param cols (number of cols)\n * @return a list of numbers\n **/\nconst generateMines = (numMines, rows, cols) => {\n  const arr = Array.from(Array(rows * cols).keys());\n\n  for (var i = rows * cols - 1; i >= 0; i--) {\n    const randNum = Math.floor(Math.random() * i); //generate random index between 0 and i\n\n    swap(arr, i, randNum);\n  }\n\n  return arr.slice(0, numMines);\n};\n\nconst swap = (arr, index1, index2) => {\n  var temp = arr[index1];\n  arr[index1] = arr[index2];\n  arr[index2] = temp;\n};\n/**\n * Generates a 2D array of numbers, where the value of each index is the number of mines a square is adjacent to\n * @param mines: list of numbers corresponding to the 1D coordinates of the squares that are mines\n * @return 2D array of numbers (col, row)\n **/\n\n\nconst generateNumbersArr = (mines, rows, cols) => {\n  const minesIn2D = mines.map(mine => {\n    const coords = convertFrom1Dto2D(mine, cols);\n    return [coords[0], coords[1]].toString();\n  });\n  var minesSet = new Set(minesIn2D); //initialize a 2D array\n\n  const newArr = new Array(rows).fill(0).map(() => new Array(cols).fill(0)); //populate the number of neighboring mines for each cell appropriately\n  //cells that are mines are set to -1\n\n  return newArr.map((row, row_index) => {\n    return row.map((_, col_index) => {\n      if (minesSet.has([col_index, row_index].toString())) return 9;\n      return numNeighbors(minesSet, col_index, row_index, cols, rows);\n    });\n  });\n};\n/**\n * Finds the number of neighbors of current cell that are mines\n * @param minesSet: set (of 2D coords) of mines\n * @param x: col_index of current cell\n * @param y: row_index of current cell\n * @return number of neighbors that are mines\n **/\n\n\nconst numNeighbors = (minesSet, x, y, cols, rows) => {\n  var mines = 0;\n\n  for (var i = Math.max(0, x - 1); i <= Math.min(cols - 1, x + 1); i++) {\n    for (var j = Math.max(0, y - 1); j <= Math.min(rows - 1, y + 1); j++) {\n      if (minesSet.has([i, j].toString())) mines += 1;\n    }\n  }\n\n  return mines;\n};\n/**\n * Converts 1D coordinate to 2D coordinate (cols, row)\n * @param mine: a number \n * @param cols: number of columns\n * @return 2D coordinate  \n **/\n\n\nconst convertFrom1Dto2D = (mines, cols) => {\n  const y = Math.floor(mines / cols);\n  const x = mines % cols;\n  return [x, y];\n};\n/**\n * Unhides the surrounding \"0\" cells of the current cell (row_index, cols_index)\n * @param hidden: a 2D boolean array [index by row, then column] \n * @param mines: 2D integer array [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return set of 2D indices that need to be hidden   \n **/\n\n\nconst unhideSurroundingSquaresWithZero = (hidden, mines, row_index, cols_index, rows, cols) => {\n  let setOfHiddenIndices = new Set();\n  let setOfSeenIndices = new Set();\n  unhideSurroundingSquaresWithZeroHelper(hidden, mines, row_index, cols_index, rows, cols, setOfHiddenIndices, setOfSeenIndices);\n  return setOfHiddenIndices;\n};\n\nconst unhideSurroundingSquaresWithZeroHelper = (hidden, mines, row_index, cols_index, rows, cols, setOfHiddenIndices, setOfSeenIndices) => {\n  setOfSeenIndices.add([row_index, cols_index].toString());\n\n  for (var i = Math.max(0, row_index - 1); i <= Math.min(rows - 1, row_index + 1); i++) {\n    for (var j = Math.max(0, cols_index - 1); j <= Math.min(cols - 1, cols_index + 1); j++) {\n      setOfHiddenIndices.add([i, j].toString());\n\n      if (mines[i][j] === 0 && !setOfSeenIndices.has([i, j].toString())) {\n        unhideSurroundingSquaresWithZeroHelper(hidden, mines, i, j, rows, cols, setOfHiddenIndices, setOfSeenIndices);\n      }\n    }\n  }\n};\n/**\n * Checks whether the number of adjacent cells flagged equals the number of the cell's neighboring mines\n * @param numMines: the number of adjacent cells which are mines\n * @param visible: 2D integer array of current status of cells [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return boolean   \n **/\n\n\nconst isFlaggedComplete = (numMines, visible, row_index, cols_index, rows, cols) => {\n  var numFlagged = 0;\n\n  for (var i = Math.max(0, row_index - 1); i <= Math.min(rows - 1, row_index + 1); i++) {\n    for (var j = Math.max(0, cols_index - 1); j <= Math.min(cols - 1, cols_index + 1); j++) {\n      if (visible[i][j] === \"flag\") {\n        numFlagged += 1;\n      }\n    }\n  }\n\n  return numFlagged === numMines;\n};\n/**\n * Unhides all neighboring cells that aren't flagged, including all \"0\" patches if a neighboring cell has \"0\" \n * @param mines: 2D integer array [index by row, then column]\n * @param visible: 2D integer array of current status of cells [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return set of 2D indices that need to be hidden   \n **/\n\n\nconst unhideAllSurroundingSquares = (visible, mines, row_index, cols_index, rows, cols) => {\n  let setOfHiddenIndices = new Set();\n\n  for (var i = Math.max(0, row_index - 1); i <= Math.min(rows - 1, row_index + 1); i++) {\n    for (var j = Math.max(0, cols_index - 1); j <= Math.min(cols - 1, cols_index + 1); j++) {\n      if (visible[i][j] === \"hidden\") setOfHiddenIndices.add([i, j].toString());\n\n      if (mines[i][j] === 0) {\n        let patchZeroSet = unhideSurroundingSquaresWithZero(visible, mines, i, j, rows, cols);\n        patchZeroSet.forEach(setOfHiddenIndices.add, setOfHiddenIndices);\n      }\n    }\n  }\n\n  return setOfHiddenIndices;\n};\n\nmodule.exports = {\n  generateMines: generateMines,\n  generateNumbersArr: generateNumbersArr,\n  convertFrom1Dto2D: convertFrom1Dto2D,\n  unhideSurroundingSquaresWithZero: unhideSurroundingSquaresWithZero,\n  isFlaggedComplete: isFlaggedComplete,\n  unhideAllSurroundingSquares: unhideAllSurroundingSquares\n};","map":{"version":3,"sources":["/Users/owenbai/Documents/Development/minesweeper.ai/src/utilities/functions.js"],"names":["generateMines","numMines","rows","cols","arr","Array","from","keys","i","randNum","Math","floor","random","swap","slice","index1","index2","temp","generateNumbersArr","mines","minesIn2D","map","mine","coords","convertFrom1Dto2D","toString","minesSet","Set","newArr","fill","row","row_index","_","col_index","has","numNeighbors","x","y","max","min","j","unhideSurroundingSquaresWithZero","hidden","cols_index","setOfHiddenIndices","setOfSeenIndices","unhideSurroundingSquaresWithZeroHelper","add","isFlaggedComplete","visible","numFlagged","unhideAllSurroundingSquares","patchZeroSet","forEach","module","exports"],"mappings":"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","sourcesContent":["/**\n * Generates a list of numbers corresponding to the 1D coordinates of the squares that are mines  \n * O(n) time, where n = rows*cols \n * @param numMines (number of mines)\n * @param rows (number of rows)\n * @param cols (number of cols)\n * @return a list of numbers\n **/\nconst generateMines = (numMines,rows, cols) => {\n  const arr = Array.from(Array(rows*cols).keys());\n  for (var i = rows*cols-1; i >= 0; i--) {\n    const randNum = Math.floor(Math.random() * i); //generate random index between 0 and i\n    swap(arr, i, randNum);\n  }\n  return arr.slice(0, numMines);\n}\n\nconst swap = (arr, index1, index2) => {\n  var temp = arr[index1];\n  arr[index1]=arr[index2];\n  arr[index2]=temp;\n}\n\n/**\n * Generates a 2D array of numbers, where the value of each index is the number of mines a square is adjacent to\n * @param mines: list of numbers corresponding to the 1D coordinates of the squares that are mines\n * @return 2D array of numbers (col, row)\n **/\nconst generateNumbersArr = (mines, rows, cols) => {\n  const minesIn2D = mines.map(mine => {\n    const coords = convertFrom1Dto2D(mine, cols)\n    return [coords[0], coords[1]].toString();\n  })\n\n  var minesSet = new Set(minesIn2D);\n\n  //initialize a 2D array\n  const newArr = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n\n  //populate the number of neighboring mines for each cell appropriately\n  //cells that are mines are set to -1\n  return newArr.map((row, row_index) => {\n    return row.map((_, col_index) => {\n      if (minesSet.has([col_index, row_index].toString())) return 9; \n      return numNeighbors(minesSet, col_index, row_index, cols, rows);\n    })\n  })\n}\n\n/**\n * Finds the number of neighbors of current cell that are mines\n * @param minesSet: set (of 2D coords) of mines\n * @param x: col_index of current cell\n * @param y: row_index of current cell\n * @return number of neighbors that are mines\n **/\nconst numNeighbors = (minesSet, x, y, cols, rows) => {\n  var mines = 0;\n  for (var i = Math.max(0, x-1); i <= Math.min(cols-1, x+1); i++) {\n    for (var j = Math.max(0, y-1); j <= Math.min(rows-1, y+1); j++) {\n      if (minesSet.has([i, j].toString())) mines+=1;\n    }\n  }\n  return mines;\n}\n\n/**\n * Converts 1D coordinate to 2D coordinate (cols, row)\n * @param mine: a number \n * @param cols: number of columns\n * @return 2D coordinate  \n **/\nconst convertFrom1Dto2D = (mines, cols) => {\n  const y = Math.floor(mines/cols);\n  const x = mines % cols;\n  return [x,y];\n}\n\n/**\n * Unhides the surrounding \"0\" cells of the current cell (row_index, cols_index)\n * @param hidden: a 2D boolean array [index by row, then column] \n * @param mines: 2D integer array [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return set of 2D indices that need to be hidden   \n **/\nconst unhideSurroundingSquaresWithZero = (hidden, mines, row_index, cols_index, rows, cols) => {\n  let setOfHiddenIndices = new Set();\n  let setOfSeenIndices = new Set();\n  unhideSurroundingSquaresWithZeroHelper(hidden, mines, row_index, cols_index, rows, cols, setOfHiddenIndices, setOfSeenIndices);\n  return setOfHiddenIndices;\n}\n\nconst unhideSurroundingSquaresWithZeroHelper = (hidden, mines, row_index, cols_index, rows, cols, setOfHiddenIndices, setOfSeenIndices) => {\n  setOfSeenIndices.add([row_index, cols_index].toString());\n  for (var i = Math.max(0, row_index-1); i <= Math.min(rows-1, row_index+1); i++) {\n    for (var j = Math.max(0, cols_index-1); j <= Math.min(cols-1, cols_index+1); j++) {\n      setOfHiddenIndices.add([i,j].toString());\n      if (mines[i][j]===0 && !setOfSeenIndices.has([i,j].toString())) {\n        unhideSurroundingSquaresWithZeroHelper(hidden, mines, i, j, rows, cols, setOfHiddenIndices, setOfSeenIndices);\n      }\n    }\n  }\n}\n\n/**\n * Checks whether the number of adjacent cells flagged equals the number of the cell's neighboring mines\n * @param numMines: the number of adjacent cells which are mines\n * @param visible: 2D integer array of current status of cells [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return boolean   \n **/\nconst isFlaggedComplete = (numMines, visible, row_index, cols_index, rows, cols) => {\n  var numFlagged = 0;\n  for (var i = Math.max(0, row_index-1); i <= Math.min(rows-1, row_index+1); i++) {\n    for (var j = Math.max(0, cols_index-1); j <= Math.min(cols-1, cols_index+1); j++) {\n      if (visible[i][j]===\"flag\") {\n        numFlagged+=1;\n      }\n    }\n  }\n  return numFlagged === numMines;\n}\n\n/**\n * Unhides all neighboring cells that aren't flagged, including all \"0\" patches if a neighboring cell has \"0\" \n * @param mines: 2D integer array [index by row, then column]\n * @param visible: 2D integer array of current status of cells [index by row, then column]\n * @param row_index: current cell row index\n * @param cols_index: current cell column index\n * @param rows (number of rows)\n * @param cols (number of columns)\n * @return set of 2D indices that need to be hidden   \n **/\nconst unhideAllSurroundingSquares = (visible, mines, row_index, cols_index, rows, cols) => {\n  let setOfHiddenIndices = new Set();\n  for (var i = Math.max(0, row_index-1); i <= Math.min(rows-1, row_index+1); i++) {\n    for (var j = Math.max(0, cols_index-1); j <= Math.min(cols-1, cols_index+1); j++) {\n      if (visible[i][j]===\"hidden\") setOfHiddenIndices.add([i,j].toString());\n      if (mines[i][j]===0) {\n        let patchZeroSet = unhideSurroundingSquaresWithZero(visible, mines, i, j, rows, cols);\n        patchZeroSet.forEach(setOfHiddenIndices.add, setOfHiddenIndices);\n      }\n    }\n  }\n  return setOfHiddenIndices;\n}\n\n\nmodule.exports = { \n  generateMines: generateMines, \n  generateNumbersArr: generateNumbersArr,\n  convertFrom1Dto2D: convertFrom1Dto2D,\n  unhideSurroundingSquaresWithZero: unhideSurroundingSquaresWithZero,\n  isFlaggedComplete: isFlaggedComplete,\n  unhideAllSurroundingSquares: unhideAllSurroundingSquares\n} "]},"metadata":{},"sourceType":"module"}